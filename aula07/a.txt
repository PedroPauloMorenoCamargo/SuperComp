paulocs5@insper.edu.br
#include <stdio.h>
#include "system.h"
#include <alt_types.h>
#include <io.h> /* For reading/writing in Avalon */
#include <altera_avalon_pio_regs.h>
#include <sys/alt_irq.h>
#include <unistd.h>
#include <stdbool.h>

volatile int edge_capture;  // To store the interrupt event
volatile bool en = 0;  // Flag to indicate interrupt has occurred
volatile bool dir = 0;
// Delay function
void delay(int n) {
    unsigned int delay = 0;
    while (delay < n) {
        delay++;
    }
}

// Interrupt handler for PIO_1
void handle_pio_interrupt(void* context, alt_u32 id) {
    // Cast context to the edge_capture pointer and store the edge capture register value
    volatile int* edge_capture_ptr = (volatile int*) context;
    *edge_capture_ptr = IORD_ALTERA_AVALON_PIO_EDGE_CAP(PIO_1_BASE);  // Read the edge capture

    // Set the interrupt flag to indicate an interrupt occurred
    int first_4_bits = (*edge_capture_ptr) & 0xF;

    if (first_4_bits & 0x1) {
    	en = !en;
    }

    if (first_4_bits & 0x2) {
    	dir = !dir;
    }


    // Reset the edge capture register to clear the interrupt for all bits
    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(PIO_1_BASE, *edge_capture_ptr);
}

// Function to initialize PIO and interrupts
void init_pio_interrupt() {
    // Recast the edge_capture pointer to match the alt_irq_register() function prototype
    void* edge_capture_ptr = (void*) &edge_capture;

    // Enable interrupts for PIO_1 (bits 0 to 10)
    IOWR_ALTERA_AVALON_PIO_IRQ_MASK(PIO_1_BASE, 0x7FF);  // Enable interrupts for bits 0-10 of PIO_1

    // Reset the edge capture register for PIO_1
    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(PIO_1_BASE, 0x0);

    // Register the interrupt handler for PIO_1
    alt_irq_register(PIO_1_IRQ, edge_capture_ptr, handle_pio_interrupt);
}

int main(void) {
    unsigned int led = 0;

    printf("Embarcados++ \n");

    // Initialize the interrupt for PIO_1
    init_pio_interrupt();

    while (1) {
        // Main LED control logic
        if (led <= 5) {
            IOWR_32DIRECT(PIO_0_BASE, 0, 0x01 << led++);
            usleep(50000);  // Sleep for 50ms
        }
        else {
            led = 0;
        }

        // Check if an interrupt occurred
        if (dir == 1) {
            usleep(500000);
            // Perform any other action you want when the interrupt occurs
        }
    }

    return 0;
}



